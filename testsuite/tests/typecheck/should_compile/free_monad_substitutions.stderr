
free_monad_substitutions.hs:12:28: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole:
        _a :: (Free f1 a -> Free f2 b) -> f1 (Free f1 a) -> f2 (Free f2 b)
      Where: ‘f1’, ‘f2’ are rigid type variables bound by
               the inferred type of go :: Free f1 a -> Free f2 b
               at free_monad_substitutions.hs:(11,7)-(12,36)
             ‘a’, ‘b’ are rigid type variables bound by
               the type signature for:
                 fmap :: forall a b. (a -> b) -> Free f a -> Free f b
               at free_monad_substitutions.hs:10:5-8
      Or perhaps ‘_a’ is mis-spelled, or not in scope
    • In the expression: _a
      In the first argument of ‘Free’, namely ‘(_a go fa)’
      In the expression: Free (_a go fa)
    • Relevant bindings include
        fa :: f1 (Free f1 a) (bound at free_monad_substitutions.hs:12:16)
        go :: Free f1 a -> Free f2 b
          (bound at free_monad_substitutions.hs:11:7)
        f :: a -> b (bound at free_monad_substitutions.hs:10:10)
        fmap :: (a -> b) -> Free f a -> Free f b
          (bound at free_monad_substitutions.hs:10:5)
      Constraints include
        Functor f (from free_monad_substitutions.hs:9:10-38)
      Valid substitutions include go :: Free f1 a -> Free f2 b
      Valid refinement substitutions include
        ($) (_ :: (Free f1 a -> Free f2 b)
                  -> f1 (Free f1 a) -> f2 (Free f2 b))
          where ($) :: forall a b. (a -> b) -> a -> b
        pure (_ :: f1 (Free f1 a) -> f2 (Free f2 b))
          where pure :: forall (f :: * -> *).
                        Applicative f =>
                        forall a. a -> f a
        (>>=) (_ :: (Free f1 a -> Free f2 b) -> a1)
              (_ :: a1
                    -> (Free f1 a -> Free f2 b) -> f1 (Free f1 a) -> f2 (Free f2 b))
          where (>>=) :: forall (m :: * -> *).
                         Monad m =>
                         forall a b. m a -> (a -> m b) -> m b
        (<*>) (_ :: (Free f1 a -> Free f2 b)
                    -> a0 -> f1 (Free f1 a) -> f2 (Free f2 b))
              (_ :: (Free f1 a -> Free f2 b) -> a0)
          where (<*>) :: forall (f :: * -> *).
                         Applicative f =>
                         forall a b. f (a -> b) -> f a -> f b
        (<$>) (_ :: a3 -> f1 (Free f1 a) -> f2 (Free f2 b))
              (_ :: (Free f1 a -> Free f2 b) -> a3)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        (=<<) (_ :: a2
                    -> (Free f1 a -> Free f2 b) -> f1 (Free f1 a) -> f2 (Free f2 b))
              (_ :: (Free f1 a -> Free f2 b) -> a2)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b

free_monad_substitutions.hs:22:31: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _a :: Free f a -> Free f b
      Where: ‘a’, ‘b’ are rigid type variables bound by
               the type signature for:
                 (>>=) :: forall a b. Free f a -> (a -> Free f b) -> Free f b
               at free_monad_substitutions.hs:21:12-14
             ‘f’ is a rigid type variable bound by
               the instance declaration
               at free_monad_substitutions.hs:20:10-40
      Or perhaps ‘_a’ is mis-spelled, or not in scope
    • In the first argument of ‘fmap’, namely ‘_a’
      In the first argument of ‘Free’, namely ‘(fmap _a f)’
      In the expression: Free (fmap _a f)
    • Relevant bindings include
        g :: a -> Free f b (bound at free_monad_substitutions.hs:22:16)
        f :: f (Free f a) (bound at free_monad_substitutions.hs:22:10)
        (>>=) :: Free f a -> (a -> Free f b) -> Free f b
          (bound at free_monad_substitutions.hs:21:12)
      Constraints include
        Applicative f (from free_monad_substitutions.hs:20:10-40)
      Valid refinement substitutions include
        fmap (_ :: a -> b)
          where fmap :: forall (f :: * -> *).
                        Functor f =>
                        forall a b. (a -> b) -> f a -> f b
        (<*>) (_ :: Free f (a -> b))
          where (<*>) :: forall (f :: * -> *).
                         Applicative f =>
                         forall a b. f (a -> b) -> f a -> f b
        (<$>) (_ :: a -> b)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        (=<<) (_ :: a -> Free f b)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b
        ($) (_ :: Free f a -> Free f b)
          where ($) :: forall a b. (a -> b) -> a -> b
        pure (_ :: Free f b)
          where pure :: forall (f :: * -> *).
                        Applicative f =>
                        forall a. a -> f a
        fmap (_ :: a0 -> Free f b) (_ :: Free f a -> a0)
          where fmap :: forall (f :: * -> *).
                        Functor f =>
                        forall a b. (a -> b) -> f a -> f b
        (<*>) (_ :: Free f a -> a1 -> Free f b) (_ :: Free f a -> a1)
          where (<*>) :: forall (f :: * -> *).
                         Applicative f =>
                         forall a b. f (a -> b) -> f a -> f b
        (<$>) (_ :: a3 -> Free f b) (_ :: Free f a -> a3)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        (=<<) (_ :: a2 -> Free f a -> Free f b) (_ :: Free f a -> a2)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b
