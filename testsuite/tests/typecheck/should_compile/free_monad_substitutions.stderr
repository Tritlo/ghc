
free_monad_substitutions.hs:12:28: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole:
        _a :: (Free f1 a -> Free f2 b) -> f1 (Free f1 a) -> f2 (Free f2 b)
      Where: ‘f1’, ‘f2’ are rigid type variables bound by
               the inferred type of go :: Free f1 a -> Free f2 b
               at free_monad_substitutions.hs:(11,7)-(12,36)
             ‘a’, ‘b’ are rigid type variables bound by
               the type signature for:
                 fmap :: forall a b. (a -> b) -> Free f a -> Free f b
               at free_monad_substitutions.hs:10:5-8
      Or perhaps ‘_a’ is mis-spelled, or not in scope
    • In the expression: _a
      In the first argument of ‘Free’, namely ‘(_a go fa)’
      In the expression: Free (_a go fa)
    • Relevant bindings include
        fa :: f1 (Free f1 a) (bound at free_monad_substitutions.hs:12:16)
        go :: Free f1 a -> Free f2 b
          (bound at free_monad_substitutions.hs:11:7)
        f :: a -> b (bound at free_monad_substitutions.hs:10:10)
        fmap :: (a -> b) -> Free f a -> Free f b
          (bound at free_monad_substitutions.hs:10:5)
      Valid substitutions include go :: t1
      Valid refinement substitutions include
        (=<<) (_ :: a0
                    -> (Free t0 t1 -> Free t2 t3)
                    -> t0 (Free t0 t1)
                    -> t2 (Free t2 t3))
              (_ :: (Free t0 t1 -> Free t2 t3) -> a0)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b
        (<$>) (_ :: a0 -> t0 (Free t0 t1) -> t2 (Free t2 t3))
              (_ :: (Free t0 t1 -> Free t2 t3) -> a0)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        pure (_ :: t0 (Free t0 t1) -> t2 (Free t2 t3))
          where pure :: forall (f :: * -> *).
                        Applicative f =>
                        forall a. a -> f a
        (<*>) (_ :: (Free t0 t1 -> Free t2 t3)
                    -> a0 -> t0 (Free t0 t1) -> t2 (Free t2 t3))
              (_ :: (Free t0 t1 -> Free t2 t3) -> a0)
          where (<*>) :: forall (f :: * -> *).
                         Applicative f =>
                         forall a b. f (a -> b) -> f a -> f b
        (>>=) (_ :: (Free t0 t1 -> Free t2 t3) -> a0)
              (_ :: a0
                    -> (Free t0 t1 -> Free t2 t3)
                    -> t0 (Free t0 t1)
                    -> t2 (Free t2 t3))
          where (>>=) :: forall (m :: * -> *).
                         Monad m =>
                         forall a b. m a -> (a -> m b) -> m b
        ($) (_ :: (Free t0 t1 -> Free t2 t3)
                  -> t0 (Free t0 t1) -> t2 (Free t2 t3))
          where ($) :: forall a b. (a -> b) -> a -> b

free_monad_substitutions.hs:22:31: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _a :: Free f a -> Free f b
      Where: ‘a’, ‘b’ are rigid type variables bound by
               the type signature for:
                 (>>=) :: forall a b. Free f a -> (a -> Free f b) -> Free f b
               at free_monad_substitutions.hs:21:12-14
             ‘f’ is a rigid type variable bound by
               the instance declaration
               at free_monad_substitutions.hs:20:10-40
      Or perhaps ‘_a’ is mis-spelled, or not in scope
    • In the first argument of ‘fmap’, namely ‘_a’
      In the first argument of ‘Free’, namely ‘(fmap _a f)’
      In the expression: Free (fmap _a f)
    • Relevant bindings include
        g :: a -> Free f b (bound at free_monad_substitutions.hs:22:16)
        f :: f (Free f a) (bound at free_monad_substitutions.hs:22:10)
        (>>=) :: Free f a -> (a -> Free f b) -> Free f b
          (bound at free_monad_substitutions.hs:21:12)
      Valid refinement substitutions include
        (=<<) (_ :: t0 -> Free t1 t2)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b
        (=<<) (_ :: a0 -> Free t1 t0 -> Free t1 t2) (_ :: Free t0 t1 -> a0)
          where (=<<) :: forall (m :: * -> *) a b.
                         Monad m =>
                         (a -> m b) -> m a -> m b
        (<$>) (_ :: a0 -> Free t0 t1) (_ :: Free t0 t1 -> a0)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        pure (_ :: Free t0 t1)
          where pure :: forall (f :: * -> *).
                        Applicative f =>
                        forall a. a -> f a
        (<*>) (_ :: Free t1 t0 -> a0 -> Free t1 t2) (_ :: Free t0 t1 -> a0)
          where (<*>) :: forall (f :: * -> *).
                         Applicative f =>
                         forall a b. f (a -> b) -> f a -> f b
        (<*>) (_ :: Free t0 (t1 -> t2))
          where (<*>) :: forall (f :: * -> *).
                         Applicative f =>
                         forall a b. f (a -> b) -> f a -> f b
        fmap (_ :: t0 -> t1)
          where fmap :: forall (f :: * -> *).
                        Functor f =>
                        forall a b. (a -> b) -> f a -> f b
        fmap (_ :: a0 -> Free t0 t1) (_ :: Free t0 t1 -> a0)
          where fmap :: forall (f :: * -> *).
                        Functor f =>
                        forall a b. (a -> b) -> f a -> f b
        (<$>) (_ :: t0 -> t1)
          where (<$>) :: forall (f :: * -> *) a b.
                         Functor f =>
                         (a -> b) -> f a -> f b
        ($) (_ :: Free t1 t0 -> Free t1 t2)
          where ($) :: forall a b. (a -> b) -> a -> b
