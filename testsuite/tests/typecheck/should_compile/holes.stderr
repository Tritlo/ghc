
holes.hs:3:5: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: t
      Where: ‘t’ is a rigid type variable bound by
               the inferred type of f :: t
               at holes.hs:3:1-5
    • In the expression: _
      In an equation for ‘f’: f = _
    • Relevant bindings include f :: t (bound at holes.hs:3:1)
      Valid hole fits include f :: forall t. t

holes.hs:6:7: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: Char
    • In the expression: _
      In an equation for ‘g’: g x = _
    • Relevant bindings include
        x :: Int (bound at holes.hs:6:3)
        g :: Int -> Char (bound at holes.hs:6:1)
      Valid hole fits include
        f :: forall t. t
        maxBound :: forall a. Bounded a => a
        minBound :: forall a. Bounded a => a

holes.hs:8:5: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: [Char]
    • In the first argument of ‘(++)’, namely ‘_’
      In the expression: _ ++ "a"
      In an equation for ‘h’: h = _ ++ "a"
    • Relevant bindings include h :: [Char] (bound at holes.hs:8:1)
      Valid hole fits include
        h :: [Char]
        f :: forall t. t
        mempty :: forall a. Monoid a => a

holes.hs:11:15: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: b0
      Where: ‘b0’ is an ambiguous type variable
    • In the second argument of ‘const’, namely ‘_’
      In the expression: const y _
      In an equation for ‘z’: z y = const y _
    • Relevant bindings include
        y :: [a] (bound at holes.hs:11:3)
        z :: [a] -> [a] (bound at holes.hs:11:1)
      Valid hole fits include
        y :: [a]
        z :: [a] -> [a]
        g :: Int -> Char
        h :: [Char]
        f :: forall t. t
