
holes.hs:3:5: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: t
      Where: ‘t’ is a rigid type variable bound by
               the inferred type of f :: t
               at holes.hs:3:1-5
    • In the expression: _
      In an equation for ‘f’: f = _
    • Relevant bindings include f :: t (bound at holes.hs:3:1)
      Valid substitutions include f :: forall t. t

holes.hs:6:7: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: Char
    • In the expression: _
      In an equation for ‘g’: g x = _
    • Relevant bindings include
        x :: Int (bound at holes.hs:6:3)
        g :: Int -> Char (bound at holes.hs:6:1)
      Valid substitutions include
        f :: forall t. t
        maxBound :: forall a. Bounded a => a
        minBound :: forall a. Bounded a => a

holes.hs:8:5: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: [Char]
    • In the first argument of ‘(++)’, namely ‘_’
      In the expression: _ ++ "a"
      In an equation for ‘h’: h = _ ++ "a"
    • Relevant bindings include h :: [Char] (bound at holes.hs:8:1)
      Valid substitutions include
        h :: [Char]
        f :: forall t. t
        mempty :: forall a. Monoid a => a

holes.hs:11:15: warning: [-Wtyped-holes (in -Wdefault)]
    • Found hole: _ :: b0
      Where: ‘b0’ is an ambiguous type variable
    • In the second argument of ‘const’, namely ‘_’
      In the expression: const y _
      In an equation for ‘z’: z y = const y _
    • Relevant bindings include
        y :: [a] (bound at holes.hs:11:3)
        z :: [a] -> [a] (bound at holes.hs:11:1)
      Valid substitutions include
        h :: [Char]
        g :: Int -> Char
        z :: [a] -> [a]
        y :: [a]
        f :: forall t. t
        Left :: forall a b. a -> Either a b
        Right :: forall a b. b -> Either a b
        EQ :: Ordering
        LT :: Ordering
        GT :: Ordering
        properFraction :: forall a.
                          RealFrac a =>
                          forall b. Integral b => a -> (b, a)
        divMod :: forall a. Integral a => a -> a -> (a, a)
        quotRem :: forall a. Integral a => a -> a -> (a, a)
        significand :: forall a. RealFloat a => a -> a
        scaleFloat :: forall a. RealFloat a => Int -> a -> a
        isDenormalized :: forall a. RealFloat a => a -> Bool
        isIEEE :: forall a. RealFloat a => a -> Bool
        isInfinite :: forall a. RealFloat a => a -> Bool
        isNaN :: forall a. RealFloat a => a -> Bool
        isNegativeZero :: forall a. RealFloat a => a -> Bool
        floatRange :: forall a. RealFloat a => a -> (Int, Int)
        floatRadix :: forall a. RealFloat a => a -> Integer
        exponent :: forall a. RealFloat a => a -> Int
        floatDigits :: forall a. RealFloat a => a -> Int
        ceiling :: forall a. RealFrac a => forall b. Integral b => a -> b
        floor :: forall a. RealFrac a => forall b. Integral b => a -> b
        round :: forall a. RealFrac a => forall b. Integral b => a -> b
        truncate :: forall a. RealFrac a => forall b. Integral b => a -> b
        encodeFloat :: forall a. RealFloat a => Integer -> Int -> a
        decodeFloat :: forall a. RealFloat a => a -> (Integer, Int)
        atan2 :: forall a. RealFloat a => a -> a -> a
        pi :: forall a. Floating a => a
        acos :: forall a. Floating a => a -> a
        acosh :: forall a. Floating a => a -> a
        asin :: forall a. Floating a => a -> a
        asinh :: forall a. Floating a => a -> a
        atan :: forall a. Floating a => a -> a
        atanh :: forall a. Floating a => a -> a
        cos :: forall a. Floating a => a -> a
        cosh :: forall a. Floating a => a -> a
        exp :: forall a. Floating a => a -> a
        log :: forall a. Floating a => a -> a
        sin :: forall a. Floating a => a -> a
        sinh :: forall a. Floating a => a -> a
        sqrt :: forall a. Floating a => a -> a
        tan :: forall a. Floating a => a -> a
        tanh :: forall a. Floating a => a -> a
        recip :: forall a. Fractional a => a -> a
        (**) :: forall a. Floating a => a -> a -> a
        logBase :: forall a. Floating a => a -> a -> a
        (/) :: forall a. Fractional a => a -> a -> a
        not :: Bool -> Bool
        (&&) :: Bool -> Bool -> Bool
        (||) :: Bool -> Bool -> Bool
        readFile :: FilePath -> IO String
        putStr :: String -> IO ()
        putStrLn :: String -> IO ()
        putChar :: Char -> IO ()
        interact :: (String -> String) -> IO ()
        getContents :: IO String
        getLine :: IO String
        getChar :: IO Char
        appendFile :: FilePath -> String -> IO ()
        writeFile :: FilePath -> String -> IO ()
        showString :: String -> ShowS
        showParen :: Bool -> ShowS -> ShowS
        showChar :: Char -> ShowS
        gcd :: forall a. Integral a => a -> a -> a
        lcm :: forall a. Integral a => a -> a -> a
        div :: forall a. Integral a => a -> a -> a
        mod :: forall a. Integral a => a -> a -> a
        quot :: forall a. Integral a => a -> a -> a
        rem :: forall a. Integral a => a -> a -> a
        even :: forall a. Integral a => a -> Bool
        odd :: forall a. Integral a => a -> Bool
        (^^) :: forall a b. (Fractional a, Integral b) => a -> b -> a
        (^) :: forall a b. (Num a, Integral b) => a -> b -> a
        readParen :: forall a. Bool -> ReadS a -> ReadS a
        lex :: ReadS String
        zipWith3 :: forall a b c d.
                    (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
        zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
        zip3 :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
        unzip3 :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
        unzip :: forall a b. [(a, b)] -> ([a], [b])
        splitAt :: forall a. Int -> [a] -> ([a], [a])
        scanr :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
        scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
        scanr1 :: forall a. (a -> a -> a) -> [a] -> [a]
        scanl :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
        replicate :: forall a. Int -> a -> [a]
        iterate :: forall a. (a -> a) -> a -> [a]
        drop :: forall a. Int -> [a] -> [a]
        take :: forall a. Int -> [a] -> [a]
        cycle :: forall a. [a] -> [a]
        init :: forall a. [a] -> [a]
        reverse :: forall a. [a] -> [a]
        tail :: forall a. [a] -> [a]
        break :: forall a. (a -> Bool) -> [a] -> ([a], [a])
        span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
        (!!) :: forall a. [a] -> Int -> a
        userError :: String -> IOError
        ioError :: forall a. IOError -> IO a
        until :: forall a. (a -> Bool) -> (a -> a) -> a -> a
        flip :: forall a b c. (a -> b -> c) -> b -> a -> c
        (.) :: forall b c a. (b -> c) -> (a -> b) -> a -> c
        uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
        curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
        unlines :: [String] -> String
        unwords :: [String] -> String
        head :: forall a. [a] -> a
        last :: forall a. [a] -> a
        lines :: String -> [String]
        words :: String -> [String]
        repeat :: forall a. a -> [a]
        maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
        either :: forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
        Just :: forall a. a -> Maybe a
        Nothing :: forall a. Maybe a
        toRational :: forall a. Real a => a -> Rational
        toInteger :: forall a. Integral a => a -> Integer
        negate :: forall a. Num a => a -> a
        abs :: forall a. Num a => a -> a
        signum :: forall a. Num a => a -> a
        fromRational :: forall a. Fractional a => Rational -> a
        realToFrac :: forall a b. (Real a, Fractional b) => a -> b
        (-) :: forall a. Num a => a -> a -> a
        subtract :: forall a. Num a => a -> a -> a
        (*) :: forall a. Num a => a -> a -> a
        (+) :: forall a. Num a => a -> a -> a
        fromInteger :: forall a. Num a => Integer -> a
        fromIntegral :: forall a b. (Integral a, Num b) => a -> b
        ($) :: forall a b. (a -> b) -> a -> b
        ($!) :: forall a b. (a -> b) -> a -> b
        id :: forall a. a -> a
        map :: forall a b. (a -> b) -> [a] -> [b]
        otherwise :: Bool
        False :: Bool
        True :: Bool
        snd :: forall a b. (a, b) -> b
        fst :: forall a b. (a, b) -> a
        zip :: forall a b. [a] -> [b] -> [(a, b)]
        filter :: forall a. (a -> Bool) -> [a] -> [a]
        dropWhile :: forall a. (a -> Bool) -> [a] -> [a]
        takeWhile :: forall a. (a -> Bool) -> [a] -> [a]
        (++) :: forall a. [a] -> [a] -> [a]
        asTypeOf :: forall a. a -> a -> a
        const :: forall a b. a -> b -> a
        seq :: forall a b. a -> b -> b
